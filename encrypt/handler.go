package encrypt

import (
	"encoding/json"
	"fmt"

	"github.com/chanbakjsd/gotrix"
	"github.com/chanbakjsd/gotrix/api"
	"github.com/chanbakjsd/gotrix/debug"
)

// setupHooks sets up handlers that are present in all sessions. It is called
// by NewSession and RestoreSession.
func (s *Session) setupHooks() error {
	if err := s.AddHandler(s.checkSync); err != nil {
		return err
	}
	return nil
}

// oneTimeKeyReturn defines the JSON structure of the data returned by libolm.
type oneTimeKeyReturn struct {
	Curve25519 map[string]string `json:"curve25519"`
}

// checkSync checks the sync response and uploads new one time keys if
// necessary.
func (s *Session) checkSync(c *gotrix.Client, resp *api.SyncResponse) {
	syncResp, err := ParseSyncResponse(resp)
	if err != nil {
		debug.Warn("error parsing sync response when checking for one-time key count")
		return
	}
	keyCount := syncResp.DeviceOneTimeKeysCount[Curve25519]
	maxCount := s.account.MaxOneTimeKeys()
	if keyCount < maxCount/2 {
		oneTimeKey, err := s.account.OneTimeKeys(maxCount - keyCount)
		if err != nil {
			debug.Warn(fmt.Sprintf("error generating one time keys: %v", err))
			return
		}
		var otk oneTimeKeyReturn
		if err := json.Unmarshal([]byte(oneTimeKey), &otk); err != nil {
			debug.Warn(fmt.Sprintf("error unmarshalling one time keys generated by libolm: %v", err))
			return
		}
		result := make(OneTimeKeys, len(otk.Curve25519))
		for keyID, key := range otk.Curve25519 {
			encodedKey := SignedCurve25519Key{
				Key: key,
			}
			signature, err := s.SignData(encodedKey)
			if err != nil {
				debug.Warn(fmt.Sprintf("error signing one time keys to upload: %v", err))
				return
			}
			encodedKey.Signatures = UserSignatures{
				s.UserID: {
					NewDeviceAlgorithmKey(s.DeviceID, Ed25519): signature,
				},
			}
			keyJSON, err := json.Marshal(encodedKey)
			if err != nil {
				debug.Warn(fmt.Sprintf("error marshalling one time keys to upload: %v", err))
				return
			}
			result[string(Curve25519.SignedAlgorithm())+":"+keyID] = keyJSON
		}
		if _, err := s.KeyUpload(DeviceKeys{}, result); err != nil {
			debug.Warn(fmt.Sprintf("error uploading one time keys: %v", err))
			return
		}
		debug.Debug(fmt.Sprintf("uploaded %d one-time keys", maxCount-keyCount))
		if err := s.account.MarkKeysAsPublished(); err != nil {
			debug.Warn(fmt.Sprintf("error marking one time keys as published: %v", err))
			return
		}
	}
}
